<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Advanced template techniques in C++ - Using templates for better coding</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/unreal.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">

                <!-- HEADER -->
                <section data-markdown>
                    <script type="text/template">
                    # Advanced template techniques in C++

                    Using templates for better coding

                    <small>[Moritz Wundke] [twitter]<br>
                    Sr. Engine Programmer at [Playspace] [ps], Official [UE4] [ue4] Community Mod and Engine contributor<br>
                    http://moritz-wundke.github.io/UsingTemplatesForBetterCoding</small>

                    [twitter]: https://twitter.com/B_Thax
                    [ps]: https://www.playspace.com
                    [ue4]: https://www.unrealengine.com/
                    </script>
                </section>

                <!-- OVERVIEW -->
                <section data-markdown>
                    <script type="text/template">
                    # Lets get to work!

                     * Quick template introduction
                     * Templates for flexible design
                     * Real examples
                     * Abstract Factory
                    </script>
                </section>

                <!-- Quick template introduction -->
                <section>
                    <section data-markdown>
                        <script type="text/template">
                        ### Quick template introduction

                         * Parsed by the _compiler_, not like macros which are _processed_ by the preprocessor _before_ the compiler
                         * Solving the macro problem 
                          * Type verification and checking
                          * No multiple evaluation
                          * Correct compile error messages
                          * Debugging

                        <aside class="notes">
                            Similar to macros but with a lot more power. What are templates and what they are not.
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Quick template introduction

                            // Min macro
                            #define min(i, j) (((i) < (j)) ? (i) : (j))

                            // Min template
                            template<class T> T min_tpl(T i, T j) { return ((i < j) ? i : j); }

                            int main()
                            {
                                int i = 9; int j = 10;
                                int m = min(i++, j);
                                std::cout << m << std::endl;

                                i = 9; j = 10;
                                m = min_tpl(i++, j);
                                std::cout << m << std::endl;

                                return 0;
                            }

                        <small>Program output:</small>

                            10
                            9

                        <aside class="notes">
                            i and j are evaluated twice, example when a post increment is in place
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Quick template introduction

                        Templates are in essence code generators for generic types. The compiler will generate
                        the appropriate code for the given type if used.

                         * Function Templates
                         * Class Templates
                         * Variable Templates (C++14)
                         * Variadic Templates (C++11)
                         * Specialization and partial specialization. Member functions can not be partially specialized:

                            template <class T, class U> T tpl(U obj);   // Base template
                            template <class U> T tpl<void, U>(U obj);   // Illegal, functions can not be partially specialized
                            template <class T> T tpl(int obj);          // Overloading is fine and totally legal

                        <aside class="notes">
                            Function templates needs to be explicitly initialized some times. PI example for variable. Variadics get used at the last example of the talk.
                        </aside>
                        </script>
                    </section>
                </section>

                <!-- Templates for flexible design -->
                <section>
                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                         * Decomposing functionality
                         * Plug & Play of behaviors
                         * Better configuration of behaviors
                         * Less code and better maintenance
                         * Will be used along other classes

                        <aside class="notes">
                            Policy or behavior templates
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                            template <class T>
                            struct NewCreator
                            {
                                static T* CreateOrNull()
                                {
                                    return new T;
                                }
                            protected:
                                ~NewCreator() {}
                            };

                            template <class T>
                            struct MallocCreator
                            {
                                static T* CreateOrNull()
                                {
                                    void* alloc = std::malloc(sizeof(T));
                                    return alloc ? return new(alloc) T : nullptr;
                                }
                            protected:
                                ~MallocCreator() {}
                            };

                            template <class T>
                            struct CloneCreator
                            {
                                CloneCreator(T* pObj = nullptr) : pBlueprint(pObj)
                                {

                                }

                                T* CreateOrNull()
                                {
                                    return pBlueprint ? pBlueprint->Clone() : nullptr;
                                }

                                T* GetClonable()
                                {
                                    return pBlueprint;
                                }
                                void SetCloneable(T* pObj)
                                {
                                    pBlueprint = pObj;
                                }
                            protected:
                                ~CloneCreator() {}
                            private:
                                T* pBlueprint;
                            };

                        <aside class="notes">
                            We have 3 different types of creation strategies. CreateOrNull is static but can be also instanced.
                            We use struct because by default all should be public (just for convenience)
                            We have to take care of the protected dtor so we do not get undefined behavior when deleting pointers
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                            class BaseObject
                            {
                            public:
                                BaseObject() { }

                                virtual void SayHi() { std::cout << "Hi from BaseObject" << std::endl; }
                            };

                            class ExtendedObject : public BaseObject
                            {
                            public:
                                ExtendedObject() : BaseObject() { }

                                virtual void SayHi() override { std::cout << "Hi from ExtendedObject" << std::endl; }
                            };

                            template <class T, template <class> class CreationPolicy>
                            class ObjectManager : public CreationPolicy<T>
                            {

                            };

                            // Predefine our object managers for each type and CreationPolicy
                            typedef ObjectManager< BaseObject, NewCreator > SimpleObjectManager;
                            typedef ObjectManager< ExtendedObject, NewCreator > SimpleExtendedObjectManager;

                        <aside class="notes">
                            
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                            int main()
                            {

                                SimpleObjectManager Manager;
                                Manager.CreateOrNull()->SayHi();

                                SimpleExtendedObjectManager ExtendedManager;
                                ExtendedManager.CreateOrNull()->SayHi();

                                return 0;
                            }

                        The output will be

                            Hi from BaseObject
                            Hi from ExtendedObject

                        <aside class="notes">
                            
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                        But can we use function templates so create can be used such as `CreateOrNull<ExtendedObject>()`?

                            struct NewCreatorFunc
                            {
                                template <class T>
                                static T* CreateOrNull()
                                {
                                    return new T;
                                }
                            protected:
                                ~NewCreatorFunc() {}
                            };

                            class ObjectManagerFunc : public NewCreatorFunc
                            {

                            };

                        Then we will use it passing the type we want to create to it

                            SimpleObjectManagerFunc OtherManager;
                            OtherManager.CreateOrNull<ExtendedObject>()->SayHi();

                        And the output will be

                            Hi from ExtendedObject

                        <aside class="notes">
                            
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                         * The first approach is way more flexible.
                         * Using function templates forces us to define the class to
                           create every-time which is bad for maintenance.
                         * Class templates are only instantiated if actually used.

                        <aside class="notes">
                            First example is using template template parameters
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                        A more advanced example of combining multiple policy based templates

                            template <
                                class T, 
                                template <class> class CheckingPolicy, 
                                template <class> ThreadingPolicy.
                                template <class> StoragePolicy
                            >
                            class SmartPtr;

                            // [Smart pointer implementation omitted]

                            typedef SmartPtr
                            <
                                BaseObject,     // The pointer type
                                EnforceNotNull, // We will ensure the pointer can not be null
                                SingleThreaded, // Pointer access is single thread only and not thread safe (no locks)
                                RefCount        // We will hold the object using a reference counter
                            >
                            BaseObjPtr;

                        <aside class="notes">
                            
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                         * Flexible designs using smaller atomic like components
                         * Easy to maintain
                         * Stable design, components are decoupled between each other, less side effects
                         * Only instanced code is actually compiled resulting in smaller binary size
                         * Compiler does more resulting in better run-time performance while using a bit more time to compile

                        <aside class="notes">
                            First example is using template template parameters
                        </aside>
                        </script>
                    </section>

                </section>


                <!-- Templates for flexible design -->
                <section>
                    <section data-markdown>
                        <script type="text/template">
                        ### Real examples

                        Compile-time Assertions

                            template <class Destination, class Source>
                            Destination ReinterpCastChecked(Source source)
                            {
                                // We ensure that the destination type can hold all bits from the source type
                                assert(sizeof(Source) <= sizeof(Destination));
                                return reinterpret_cast<Destination>(source);
                            }

                        Using a simple template that does not exist and the compiler will yield the error

                            template<bool> struct ctCheck;
                            template<> struct ctCheck<true> {};

                            #define STATIC_CHECK(expr, msg) \
                                { ctCheck<((expr) != 0)> ERROR_##msg; (void)ERROR_##msg; } 

                            template <class Destination, class Source>
                            Destination ReinterpCastChecked(Source source)
                            {
                                STATIC_CHECK(sizeof(Source) <= sizeof(Destination), Destination_is_smaller_than_source)
                                return reinterpret_cast<Destination>(source);
                            }

                        In the first example we will assert on run-time, while the later does the same but in compile time.

                        <aside class="notes">
                            
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Real examples

                        Compile-time Assertions

                            // We might typedef uint8 wrongly on a given platform which would result in very bad bugs
                            STATIC_CHECK(sizeof(uint8) == 1, uint8_wrong_size)

                        When typedefing base types it is vital to ensure that they are correct, with our STATIC_CHECK we have now the power to do so.
                        In case our uint8 does not size exactly 1 byte we will see the following compile time error in MVSC:

                            error C2079: 'ERROR_uint8_wrong_size' uses undefined struct 'ctCheck<false>'

                        Recent versions of C++ come with built-in support for compile time asserts, if you are using one of those versions I encourage you to use *static_assert*.

                        <aside class="notes">
                            
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Real examples

                        Partial Specialization

                        The compiler will performs pattern matching to instantiate the correct version of your template. We cannot partially specialize member functions.

                            template<class Container, class Controller>
                            class Widget
                            {
                            public:
                                void SomeMethod()
                                {
                                    std::cout << "Widget Generic" << std::endl;
                                }
                            };

                            template<>
                            class Widget<ContainerA, ControllerA>
                            {
                            public:
                                void SomeMethod()
                                {
                                    std::cout << "Widget<ContainerA, ControllerA> Specialization" << std::endl;
                                }
                            };

                        <aside class="notes">
                            The first one is our generic implementation. The second is a specialization for a specific container and controller. 
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Real examples

                        Partial Specialization

                            template<class Container>
                            class Widget<Container, ControllerA>
                            {
                            public:
                                void SomeMethod()
                                {
                                    std::cout << "Widget<" << typeid(Container).name() << ", ControllerA> Specialization" << std::endl;
                                }
                            };

                            template<class ContainerArg>
                            class Widget<ContainerWithArg<ContainerArg>, ControllerA>
                            {
                            public:
                                void SomeMethod()
                                {
                                    std::cout << "Widget<" << typeid(ContainerWithArg<ContainerArg>).name() 
                                              << ", ControllerA> Specialization" << std::endl;
                                }
                            };

                        <aside class="notes">
                            The first one is a partial specialization for any container type but for Controller A. The second is yet another partial specialization but this time
                            for a specific compiler that has a single argument type.
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Real examples

                        Partial Specialization

                        Instantiating each of our specializations and calling *SomeMethod* we will get the following output

                            Widget Generic
                            Widget <ContainerA, ControllerA> Specialization
                            Widget <int, ControllerA> Partial Specialization
                            Widget <class ContainerWithArg<int>, ControllerA> Partial Specialization

                        <aside class="notes">
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Real examples

                        Adapter Pattern

                            class IShootingInterface
                            {
                            public:
                                virtual void Shoot() = 0;
                            };

                            template<class T, class P>
                            IShootingInterface* MakeShootingAdapter(const T& obj, const P& arg)
                            {
                                class AdapterImpl : public IShootingInterface
                                {
                                public:
                                    AdapterImpl(const T& obj, const P& arg)
                                        : _obj(obj), _arg(arg) { }

                                    virtual void Shoot() override
                                    {
                                        _obj.Call(_arg);
                                    };
                                private:
                                    T _obj;
                                    P _arg;
                                };
                                return new AdapterImpl(obj, arg);
                            }

                            class BaseType
                            {

                            };

                            class Soldier : BaseType
                            {
                            public:
                                void ShootRifle()
                                {
                                    std::cout << "Shooting Rifle" << std::endl;
                                }
                            };

                            class Tank : BaseType
                            {
                            public:
                                void ShootCannon()
                                {
                                    std::cout << "Shooting Cannon" << std::endl;
                                }
                            };

                            class SoldierShootAdapter
                            {
                            public:
                                void Call(Soldier& soldier)
                                {
                                    soldier.ShootRifle();
                                }
                            };

                            class TankShootAdapter
                            {
                            public:
                                void Call(Tank& tank)
                                {
                                    tank.ShootCannon();
                                }
                            };

                        <aside class="notes">
                            The inner class is only visible in the given scope and the class itself is sealed.
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Real examples

                        Adapter Pattern

                            // Create instanced and adapters
                            Soldier soldier = Soldier();
                            SoldierShootAdapter soldierAdapter = SoldierShootAdapter();

                            Tank tank = Tank();
                            TankShootAdapter tankAdapter = TankShootAdapter();

                            // Now we create our interface adapters
                            IShootingInterface* soldierShooter = MakeShootingAdapter(soldierAdapter, soldier);
                            IShootingInterface* tankShooter = MakeShootingAdapter(tankAdapter, tank);

                            // We shoot using the common interfaces
                            soldierShooter->Shoot();
                            tankShooter->Shoot();

                        <aside class="notes">
                            
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Real examples

                        Switch Template

                        Consider a multi-method class that uses an int template param to identify the right implementation.

                            template<int Method>
                            class MultiMethodSimple
                            {
                            private:
                                void MethodImplementation0()
                                {
                                    std::cout << "MethodImplementation0" << std::endl;
                                }

                                void MethodImplementation1()
                                {
                                    std::cout << "MethodImplementation1" << std::endl;
                                }
                            public:
                                void DoMethod()
                                {
                                    switch (Method)
                                    {
                                    case 0:
                                        MethodImplementation0();
                                        break;
                                    case 1:
                                        MethodImplementation1();
                                        break;
                                    default:
                                        throw "Method not defined!";
                                    }
                                }
                            };

                        <aside class="notes">
                            
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Real examples

                        Switch Template

                        The previous code has some serious issues

                         * No compile time validation for methods
                         * Run-time exceptions, environments without exceptions will be doomed
                         * Increasing code size

                        So how can we improve it and taking advantage of template instantiation?

                        <aside class="notes">
                            All instances will have all method compiled in, we can not detect non existing methods in compile time and we might run into crashes in runtime.
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Real examples

                        Switch Template

                            template<int V>
                            struct SwitchType
                            {
                                enum { value = V };
                            };

                            template<int Method>
                            class MultiMethodClass
                            {
                            private:
                                void MethodImplementation(SwitchType<0>)
                                {
                                    std::cout << "MethodImplementation(SwitchType<0>)" << std::endl;
                                }

                                void MethodImplementation(SwitchType<1>)
                                {
                                    std::cout << "MethodImplementation(SwitchType<1>)" << std::endl;
                                }
                            public:
                                void DoMethod()
                                {
                                    MethodImplementation(SwitchType<Method>());
                                }
                            };

                        <aside class="notes">
                            All instances will have all method compiled in, we can not detect non existing methods in compile time and we might run into crashes in run-time.
                        </aside>
                        </script>
                    </section>                    

                </section>

                <!-- Typelists -->
                <section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Type Lists

                        Type lists are a powerful tool for generic programming. They provide a way to express and manipulate collections of types, generate data structures or even code from those collections.

                        Again, you can implement the same with variadic templates in recent C++ versions (just wait for the last part ^^) but for now we will implement it the old fashion way to show you the power of templates.
                        
                        <aside class="notes">

                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Type Lists

                        Before we go into the realm of type lists we have to define two special types to define edge cases in our algorithms

                            class NullType {}; // Defines our null values for types, used like a mark for the end of a type list

                        Now let us define what a type list is

                            template <class T, class U>
                            struct Typelist
                            {
                                typedef T Head;
                                typedef U Tail;
                            };

                            // Typelist defining all available char types, note the NullType at the end?
                            typedef Typelist<char, Typelist<signed char, Typelist<unsigned char, NullType>>> CharTypelist;

                            // Too make our life easier we will pre define those lists
                            #define TYPE_LIST_1(T1) Typelist<T1, NullType>
                            #define TYPE_LIST_2(T1, T2) Typelist<T1, TYPE_LIST_1(T2)>
                            #define TYPE_LIST_3(T1, T2, T3) Typelist<T1, TYPE_LIST_2(T2, T3)>

                            typedef TYPE_LIST_3(char, signed char, unsigned char) CharacterTypes;

                        Type list manipulation is implemented though compile time recursion, the idea is very similar to recursive run-time code so you should be familiar with it.
                        
                        <aside class="notes">
                        
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Type Lists

                        Get length of a Type List

                            template <class TList> struct Length;
                            template <> struct Length<NullType>
                            {
                                enum { value = 0 };
                            };
                            template <class T, class U>
                            struct Length <Typelist<T, U>>
                            {
                                enum { value = 1 + Length<U>::value };
                            };
                        
                        <aside class="notes">
                            Explain the recursive algo
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Type Lists

                        Get la type at a given index

                            template <class TList, unsigned int index> struct TypeAt;

                            template <class Head, class Tail>
                            struct TypeAt<Typelist<Head, Tail>, 0>
                            {
                                typedef Head result;
                            };

                            template <class Head, class Tail, unsigned int i>
                            struct TypeAt<Typelist<Head, Tail>, i>
                            {
                                typedef typename TypeAt<Tail, i - 1>::result result;
                            };

                        
                        <aside class="notes">
                            Explain the recursive algo
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Type Lists

                        We will then use the algorithms just as any other method but it will resolve in compile time

                            std::cout << "Number of character types: " << Length<CharacterTypes>::value << std::endl;
                            std::cout << "Type at index 1: " << typeid(TypeAt<CharacterTypes, 1>::result).name() << std::endl;
                        
                        And it will give us the following output

                            Number of character types: 3
                            Type at index 1: signed char

                        <aside class="notes">
                        </aside>
                        </script>
                    </section>

                </section>

                <!-- Abstract Facory -->
                <section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Abstract Factory

                        As we said before we will use a type list as the one before to implement a simple AbstractFactory. Keep in mind that there is
                        room for improvement and the factory is not meant to be completed.

                        A simple case where you can take use of type lists is creating Abstract Factories such as the following example

                            typedef AbstractFactory<BuildTypelist<Soldier, Tank>::result> EnemyFactory;
                            AbstractFactoryImpl<EnemyFactory> factory = AbstractFactoryImpl<EnemyFactory>();
                            auto soldier = factory.Create<Soldier>();
                        
                        <aside class="notes">
                            All instances will have all method compiled in, we can not detect non existing methods in compile time and we might run into crashes in run-time.
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Abstract Factory

                        We do need to define some more tools. Fist we need something to overload a
                        method for pattern matching. Similar to what we did for the multi-method but
                        using a type instead.

                            template <typename T>
                            struct Type2Type
                            {
                                typedef T OriginalType;
                            };

                        The next component we need is the AbstractProducer. It defines the CreationPolicy
                        just as in our first example but using the *Type2Type* overload

                            template <class T>
                            class AbstarctProducer
                            {
                            public:
                                virtual T* DoCreate(Type2Type<T>) = 0;
                                virtual ~AbstarctProducer() {}
                            };
                        
                        <aside class="notes">
                            All instances will have all method compiled in, we can not detect non existing methods in compile time and we might run into crashes in run-time.
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Abstract Factory

                        It's actually our interface of what an AbstractFactory for a type list shall look like.

                            template <class T>
                            class AbstarctProducer
                            {
                            public:
                                virtual T* DoCreate(Type2Type<T>) = 0;
                                virtual ~AbstarctProducer() {}
                            };

                            template
                            <
                                class TList,
                                template <class> class Producer = AbstarctProducer
                            >
                            class AbstractFactory : public GenScatterHierarchy<TList, Producer>
                            {
                            public:
                                typedef TList ClassList;

                                template <class T> T* Create()
                                {
                                    Producer<T>& unit = *this;
                                    return unit.DoCreate(Type2Type<T>());
                                }
                            };

                        You might have noticed *GenScatterHierarchy*, it is a template that will generate a scattered hierarchy, what I mean by this is that each of the classes in it
                        defines a pure virtual *Create* method for each type in the type list. This way we ensure that all types have the right method generated at compile time.
                        
                        <aside class="notes">
                            All instances will have all method compiled in, we can not detect non existing methods in compile time and we might run into crashes in run-time.
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Abstract Factory

                        Now the implementation of the interface

                             template <class NewClass, class Base>
                            class NewCreator : public Base
                            {
                                typedef typename Base::ClassList BaseClassList;

                            protected:
                                typedef typename BaseClassList::Tail ClassList;

                            public:
                                typedef typename BaseClassList::Head AbstractClass;
                                NewClass* DoCreate(Type2Type<AbstractClass>)
                                {
                                    return new NewClass;
                                }
                            };

                            template
                            <
                                class AbstractFact,
                                template <class, class> class Creator = NewCreator,
                                class TList = typename AbstractFact::ClassList
                            >
                            class AbstractFactoryImpl
                                : public GenLinearHierarchy<
                                    typename Reverse<TList>::result, Creator, AbstractFact>
                            {
                            public:
                                typedef typename AbstractFact::ClassList ClassList;
                                typedef TList ConcreteClassList;
                            };

                        This time we have a *GenLinearHierarchy* template here and a reverse. The first generates a linear hierarchy in bottom-up fashion while *DoCreate* expects the list to be in top-bottom fashion so we have to reverse.

                        <small>Don't worry about the code, it's all in the GitHub repo</small>
                        
                        
                        <aside class="notes">
                            
                        </aside>
                        </script>
                    </section>

                </section>

                <!-- More Info -->
                <section data-markdown>
                    <script type="text/template">
                    ### Recommened read

                    Now that you dived a bit into the template world I encourage you to dig deeper. The following links are a perfect starting point.

                     * [Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14][EffectiveModernC++]
                     * [Modern C++ Design: Generic Programming and Design Patterns Applied][ModernC++Design]

                    <small>Examples based on the Loki library Copyright (c) 2001 by Andrei Alexandrescu</small>

                    [EffectiveModernC++]: https://www.amazon.es/Effective-Modern-Specific-Ways-Improve/dp/1491903996
                    [ModernC++Design]: https://www.amazon.es/Modern-Design-Generic-Programming-Patterns/dp/0201704315
                    </script>
                </section>

                <!-- Footer -->
                <section data-markdown>
                    <script type="text/template">
                    # Thanks for listening!

                    ## Any questions? Now is your time.

                    <small>[Slides] [slides] and the [source] [source] are freely available on GitHub (https://github.com/moritz-wundke)</small>

                    [slides]: http://moritz-wundke.github.io/UsingTemplatesForBetterCoding
                    [source]: https://github.com/moritz-wundke/UsingTemplatesForBetterCoding
                    </script>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                  history: true
                , transition: 'convex'
                , backgroundTransition: 'convex'

                // Viewport
                , width: 960
                , height: 700
                , margin: 0.1
                , minScale: 0.2
                , maxScale: 1.5

                // More info https://github.com/hakimel/reveal.js#dependencies
                , dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>
