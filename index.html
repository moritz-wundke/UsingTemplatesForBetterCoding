<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Advanced template techniques in C++ - Using templates for better coding</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/unreal.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">

                <!-- HEADER -->
                <section data-markdown>
                    <script type="text/template">
                    # Advanced template techniques in C++

                    Using templates for better coding

                    <small>[Moritz Wundke] [twitter]<br>
                    Sr. Programmer at [Playspace] [ps], Official [UE4] [ue4] Community Mod and Engine contributor</small>

                    [twitter]: https://twitter.com/B_Thax
                    [ps]: https://www.playspace.com
                    [ue4]: https://www.unrealengine.com/
                    </script>
                </section>

                <!-- OVERVIEW -->
                <section data-markdown>
                    <script type="text/template">
                    # Lets get to work!

                     * Quick template introduction
                     * Templates for flexible design
                     * Basic examples
                     * Advanced examples
                     * Templates applied to design patterns
                    </script>
                </section>

                <!-- Quick template introduction -->
                <section>
                    <section data-markdown>
                        <script type="text/template">
                        ### Quick template introduction

                         * Parsed by the _compiler_, not like macros which are _processed_ by the preprocessor _before_ the compiler
                         * Solving the macro problem 
                          * Type verification and checking
                          * No multiple evaluation
                          * Correct compile error messages
                          * Debugging

                        <aside class="notes">
                            Similar to macros but with a lot more power. What are templates and what they are not.
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Quick template introduction

                            // Min macro
                            #define min(i, j) (((i) < (j)) ? (i) : (j))

                            // Min template
                            template<class T> T min_tpl(T i, T j) { return ((i < j) ? i : j); }

                            int main()
                            {
                                int i = 9; int j = 10;
                                int m = min(i++, j);
                                std::cout << m << std::endl;

                                i = 9; j = 10;
                                m = min_tpl(i++, j);
                                std::cout << m << std::endl;

                                return 0;
                            }

                        <small>Program output:</small>

                            10
                            9

                        <aside class="notes">
                            i and j are evaluated twice, example when a post increment is in place
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Quick template introduction

                        Templates are in essence code generators for generic types. The compiler will generate
                        the appropriate code for the given type if used.

                         * Function Templates
                         * Class Templates
                         * Variable Templates (C++14)
                         * Variadic Templates (C++11)
                         * Specialization and partial specialization. Member functions can not be partially specialized:


                            template <class T, class U> T tpl(U obj);   // Base template
                            template <class U> T tpl<void, U>(U obj);   // Illegal, functions can not be partially specialized
                            template <class T> T tpl(int obj);          // Overloading is fine and totally legal

                        <aside class="notes">
                            Function templates needs to be explicitly initialized some times. PI example for variable. We wont cover
                            variable or variadic templates here, it would make our life too easy xD
                        </aside>
                        </script>
                    </section>
                </section>

                <!-- Templates for flexible design -->
                <section>
                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                         * Decomposing functionality
                         * Plug & Play of behaviours
                         * Better configuration of behaviours
                         * Less code and better maintenance
                         * Will be used along other classes

                        <aside class="notes">
                            Policy or behaviour templates
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                            template <class T>
                            struct NewCreator
                            {
                                static T* CreateOrNull()
                                {
                                    return new T;
                                }
                            protected:
                                ~NewCreator() {}
                            };

                            template <class T>
                            struct MallocCreator
                            {
                                static T* CreateOrNull()
                                {
                                    void* alloc = std::malloc(sizeof(T));
                                    return alloc ? return new(alloc) T : nullptr;
                                }
                            protected:
                                ~MallocCreator() {}
                            };

                            template <class T>
                            struct CloneCreator
                            {
                                CloneCreator(T* pObj = nullptr) : pBlueprint(pObj)
                                {

                                }

                                T* CreateOrNull()
                                {
                                    return pBlueprint ? pBlueprint->Clone() : nullptr;
                                }

                                T* GetClonable()
                                {
                                    return pBlueprint;
                                }
                                void SetCloneable(T* pObj)
                                {
                                    pBlueprint = pObj;
                                }
                            protected:
                                ~CloneCreator() {}
                            private:
                                T* pBlueprint;
                            };

                        <aside class="notes">
                            We have 3 different types of creation strategies. CreateOrNull is static but can be also instanced.
                            We use struct because by default all should be public (just for convinience)
                            We have to take care of the protected dtor so we do not get undefined behaviour when deleting pointers
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                            class BaseObject
                            {
                            public:
                                BaseObject() { }

                                virtual void SayHi() { std::cout << "Hi from BaseObject" << std::endl; }
                            };

                            class ExtendedObject : public BaseObject
                            {
                            public:
                                ExtendedObject() : BaseObject() { }

                                virtual void SayHi() override { std::cout << "Hi from ExtendedObject" << std::endl; }
                            };

                            template <class T, template <class> class CreationPolicy>
                            class ObjectManager : public CreationPolicy<T>
                            {

                            };

                            // Predefine our object managers for each type and CreationPOlicy
                            typedef ObjectManager< BaseObject, NewCreator > SimpleObjectManager;
                            typedef ObjectManager< ExtendedObject, NewCreator > SimpleExtendedObjectManager;

                        <aside class="notes">
                            
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                            int main()
                            {

                                SimpleObjectManager Manager;
                                Manager.CreateOrNull()->SayHi();

                                SimpleExtendedObjectManager ExtendedManager;
                                ExtendedManager.CreateOrNull()->SayHi();

                                return 0;
                            }

                        The output will be

                            Hi from BaseObject
                            Hi from ExtendedObject

                        <aside class="notes">
                            
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                        But can we use function templates so create can be used such as `CreateOrNull<ExtendedObject>()`?

                            struct NewCreatorFunc
                            {
                                template <class T>
                                static T* CreateOrNull()
                                {
                                    return new T;
                                }
                            protected:
                                ~NewCreatorFunc() {}
                            };

                            class ObjectManagerFunc : public NewCreatorFunc
                            {

                            };

                        Then we will use it passing the type we want to create to it

                            SimpleObjectManagerFunc OtherManager;
                            OtherManager.CreateOrNull<ExtendedObject>()->SayHi();

                        And the output will be

                            Hi from ExtendedObject

                        <aside class="notes">
                            
                        </aside>
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                        ### Templates for flexible design

                         * The first approach is way more flexible.
                         * Using function templates forces us to define the class to
                           create everytime whis is bad for maintenance.
                         * Class templates are only instanciated if actually used.



                        <aside class="notes">
                            First example is using template template parameters
                        </aside>
                        </script>
                    </section>

                </section>

                <!-- More Info -->
                <section data-markdown>
                    <script type="text/template">
                    ### Recommened read

                    Now that you dived a bit into the template world I encourage you to dig deeper. The following links are a perfect starting point.

                     * [Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14][EffectiveModernC++]
                     * [Modern C++ Design: Generic Programming and Design Patterns Applied][ModernC++Design]

                    [EffectiveModernC++]: https://www.amazon.es/Effective-Modern-Specific-Ways-Improve/dp/1491903996
                    [ModernC++Design]: https://www.amazon.es/Modern-Design-Generic-Programming-Patterns/dp/0201704315
                    </script>
                </section>

                <!-- Footer -->
                <section data-markdown>
                    <script type="text/template">
                    # Thanks for listening!

                    ## Any questions? Now is your time.

                    <small>[Slides] [slides] and the full [project] [project] are freely avaiulable on GitHub</small>

                    [slides]: http://moritz-wundke.github.io/UsingTemplatesForBetterCoding
                    [project]: https://github.com/moritz-wundke/UsingTemplatesForBetterCoding
                    </script>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                  history: true
                , transition: 'convex'
                , backgroundTransition: 'convex'

                // Viewport
                , width: 960
                , height: 700
                , margin: 0.1
                , minScale: 0.2
                , maxScale: 1.5

                // More info https://github.com/hakimel/reveal.js#dependencies
                , dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>
